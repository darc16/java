queryForRowSet() - set of values for the full row(s) from the database. returns SQLRowSet Object. rs.next() to get each record rs.get("fieldname") to get values.
queryForList() - list is individual values from query, if no results empty list
queryForMap() - map of fields and values from a single row
queryForObject(sql, object class) - single field value and one row. Multiple rows will blow up.
        get count or get database time. For counts on joins this could blow up use queryforrowset instead and check rs.next()
         String sql = "Select count(*) from indicators";
        JdbcTemplate jt = new JdbcTemplate(this.dataSource);
        SqlRowSet rs = jt.queryForRowSet(sql);
        int count = 0;
        if(rs.next()){
            count = rs.getInt("count");
        }
query() - row mapper
update() - returns the number of affected rows

BeanPropertyRowMapper rowMapper = new BeanPropertyRowMapper(ShortReport.class);

        String sql ="Select id, description, display_name from reports";
        JdbcTemplate jt = new JdbcTemplate(this.dataSource);

        List<ShortReport> shortReports = jt.query(sql, rowMapper);

        return shortReports;

get counts using a string for the date

select to_char(created_date, 'YYYY-mm'), count(to_char(created_date, 'YYYY-mm')) from reports group by to_char(created_date, 'YYYY-mm')

select indicator_types.name, count(indicator_types.name)
from indicators
join indicator_types on indicators.ind_type = indicator_types.id
group by indicator_types.name;


Joins

left - matches and everything on the left. (left is the first table referenced in the select)
right - matches and everything on the right
innner - default will only get things that match on both sides
outer full - will get everything

COALESCE(users.full_name,'Unknown') - returns the first non-null value, if null it returns the second variable.


select sales.sell_date, sales.value, 
case 
when users.full_name is null then 'Unknown' else users.full_name end
from sales
left join users on sales.salesperson_id = users.id;

COALESCE(sales.sell_date::varchar,'N/A') -- allow string values in a number or other type of field :: lets you cast to a different type.
